# 5월 2주차

## &#x20;브라우저 렌더링

{% hint style="info" %}
웹서버로부터 HTML 파일을 받아 브라우저에 뿌려주는 과정
{% endhint %}



### 렌더링 과정

1. 웹 서버에 HTML 응답받음
2. HTML 문서를 파싱하여 DOM tree, CSS 파싱하여 CSSOM tree
3. 두 개의 tree 결합하여 렌더링 트리 형성(\* 1:1 대응이 아님, head 태그는 포함되지 않는다)
4. 뷰 포트 내의 위치와 크기 계산(레이아웃 = 리플로우)
5. 화면에 그린다(페인팅 = 레스터화)



{% hint style="info" %}
리플로우가 일어나면 리페인팅이 필연적으로 일어나므로 리플로우를 줄이는 방법이 성능에 중요
{% endhint %}

### 레이아웃 줄이는 방법?

> 영향을 주는 주요 속성 및 메서드
>
> * document, window객체의 위치 속성 및 메서드
> * image, svg의 위치 속성 및 크기 속성

1. 캐싱

```javascript
// BAD ❌
let width = 0;
for (let i = 0; i < 10; i++) {
    width += element.offsetWidth;
}

// GOOD ✅
let width = 0;
const { offsetWidth } = element;
for (let i = 0; i < 10; i++) {
    width += offsetWidth;
}
```

2. 인라인 스타일 사용 X
3. DOM 요소 작업은 grouping(요소를 가져온 후 style 값을 수정하면 리플로우가 한번만 일어남)

```javascript
// BAD ❌
let el1 = document. querySelector('.target-first');
el1.style.width = '10px';

let el2 = document. querySelector('.target-second');
el2.style.width = '10px';

// GOOD ✅
let el1 = document. querySelector('.target-first');
let el2 = document. querySelector('.target-second');

el1.style.width = '10px';
el2.style.width = '10px';
```

4. display: none으로 작업 후 적용
5. node clone 작업 후 적용(= Virtual DOM과 비슷한 맥락)



### 렌더링 종류

{% hint style="info" %}
CSR은 유저 인터렉션 많을 때 적합

SSR은 동적 콘텐츠를 처리하는 데 더 적합

SSG은 정적 콘텐츠를 처리하는 데 적합
{% endhint %}

`SSR`: 서버에서 웹 페이지를 브라우저로 보내기 전에, 서버에서 완전히 렌더링했기 때문에 Server Side Rendering

`CSR`: CSR은 클라이언트에서 페이지를 렌더링, Javascript파일을 서버로부터 다운로드 받은 다음 동적 HTML 생성

* 번들사이즈줄이기 위해할 수 있는 것? tree-shaking, code-spliting

`SSG`(Static Site Generation)**:** 페이지에 대한 정적 HTML 파일을 모두 생성하는 방식(용량이 크면 부적합)

* Next.js의 공식문서에서는 SSG 방식을 권장하고 있습니다. CSR & SSR과 비교했을 때 렌딩 속도도 빠르고, 굳이 업데이트가 잦지 않은 페이지에 대해서 불필요한 통신과 리렌더링을 줄여주기 때문

`ISR`(Incremental Static Regeneration): revalidate가 필요한 SSG 페이지에 적합

* SSG와는 달리, ISR은 설정된 시간이 지나면 자동으로 re-build하고, 데이터를 업데이트(revalidate)합니다. SSG와 마찬가지로 getStaticProps를 가질 수 있는데, revalidate 옵션으로 시간을 설정하면 그 주기에 맞추어 서버 사이드 데이터를 업데이트



### Pre 렌더링

React의 CSR이 초기 로딩 속도가 길어 이 로딩 속도를 개선하고 사용자 경험을 더 좋게 하기 위해서 고안

\-> TTV가 빨라진다(SSG, SSR)



### 용어 정리

`TTV` = Time To View: 유저가 사이트를 볼 수 있는 타이밍

`TTI` = Time To Interact: 유저가 인터렉트할 수 있는 타이밍

`tree shaking`: 사용하지 않는 코드를 제거하는 자동화된 프로세스(webpack과 같은 번들러를 통해 적용)

`code spliting`: 코드를 작은 조각으로 분할하여 적절한 시점에 로드를 유도하는 방법(브라우저의 동적 import = React.lazy)
