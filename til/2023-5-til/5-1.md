# 5월 1주차

## Javascript 타입 변환

* 단항 연결 연산자(=> 숫자 타입)

```javascript
// 문자열 타입 => 숫자 타입
console.log(+'0');     // 0
console.log(+'-1');    // -1
console.log(+'10.53'); // 10.53

// 불리언 타입 => 숫자 타입
console.log(+true);    // 1
console.log(+false);   // 0
```



* 산술 연산자(=> 숫자타입)

```javascript
// 문자열 타입 => 숫자 타입
console.log('0' * 1);     // 0
console.log('-1' * 1);    // -1
console.log('10.53' * 1); // 10.53
// 불리언 타입 => 숫자 타입
console.log(true * 1);    // 1
console.log(false * 1);   // 0
```



* 부정 논리연산자 두번 사용(=> Boolean 타입)

```javascript
// 문자열 타입 => 불리언 타입
console.log(!!'x');       // true
console.log(!!'');        // false
console.log(!!'false');   // true
// 숫자 타입 => 불리언 타입
console.log(!!0);         // false
console.log(!!1);         // true
console.log(!!NaN);       // false
console.log(!!Infinity);  // true
// null 타입 => 불리언 타입
console.log(!!null);      // false
// undefined 타입 => 불리언 타입
console.log(!!undefined); // false
// 객체 타입 => 불리언 타입
console.log(!!{});        // true
console.log(!![]);        // true
```



## Javascript Object

{% hint style="info" %}
객체: 메모리 예측 안되므로 런타임에 메모리 공간을 확보하고 메모리의 힙 영역(Heap Segment)에 저장

원시타입: 런타임(변수 할당 시점)에 메모리의 스택 영역(Stack Segment)에 고정된 메모리 영역을 점유
{% endhint %}



* 예약어

```
// *는 ES6에서 추가된 예약어
abstract  arguments boolean break byte
case  catch char  class*  const
continue  debugger  default delete  do
double  else  enum* eval  export*
extends*  false final finally float
for function  goto  if  implements
import* in  instanceof  int interface
let long  native  new null
package private protected public  return
short static  super*  switch  synchronized
this  throw throws  transient true
try typeof  var void  volatile
while with  yield
```



* 순회(for-in, for-of)

```javascript
// 객체의 순회 단, 순서 보장 X
for (var key in person) {
  console.log(key + ': ' + person[key]);
}

// ES6에서 for-of 문이 추가 - 배열 순서보장
for (const value of array) {
  console.log(value);
}
```



## Javascript Immutability

### Immutable value

* 일반적으로 원시 타입
* 메모리 영역에서 변경 불가(재할당만 가능)

### Mutable value

* 일반적으로 객체
* Immutable data pattern
  * 객체 복사: `Object.assign()`
  * 불변 객체화: `Object.freeze(`)
  * Immutable.js



## Javascript 함수 정의

### 함수 선언문

```javascript
function hello(name) {
    console.log(`Hello ${name}`);
}
```



### 함수 표현식

```javascript
const helloworld = function hello(name) {
    console.log(`Hello ${name}`);
}

hello('deok'); // ❌ fail
helloworld('deok'); // ✅ success
```



Q. 선언문에서 `hello('name')` 쓸 수 있는 이유?

A. JS 엔진에 의해 같은 이름의 변수에 할당한 선언문으로 변환

```javascript
function hello(name) {
    console.log(`Hello ${name}`);
}

const hello = function hello(name) {
    console.log(`Hello ${name}`);
}
```



## Javascript 함수 호이스팅

{% hint style="info" %}
JS는 \*ES6의 모든 선언을 \*호이스팅
{% endhint %}

\*ES6 선언: var, let, const, function, class

\*호이스팅: Scope의 선두로 옮겨진 것처럼 동작



선언문은 JS엔진 script 로딩 시점에 초기화하여 VO에 저장 = 선언 + 초기화 + 할당

표현식은 변수 호이스팅되어 로딩 시점에 생성하여 초기화(undefined)하고 할당은 분리됨(VO에 바로 저장 안됨)

\-> ES6의 arrow function도 표현



## 출처

* [https://poiemaweb.com/](https://poiemaweb.com/)
